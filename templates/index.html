<!DOCTYPE html>
<html>
<head>
    <title>MNIST Training Monitor</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        
        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .config-section {
            flex: 0 0 400px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .plots-section {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 { 
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: inline-block;
            width: 150px;
            color: #555;
            font-size: 0.9em;
        }
        
        select, input {
            width: 200px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        #startButton {
            background: #28a745;
            color: white;
        }
        
        #stopButton {
            background: #dc3545;
            color: white;
            display: none;
        }
        
        #startButton:hover { background: #218838; }
        #stopButton:hover { background: #c82333; }
        
        .progress-container {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .progress-bar {
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #007bff;
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .progress-stats {
            display: flex;
            justify-content: space-between;
            color: #666;
            font-size: 0.9em;
        }
        
        #plots {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .status-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .status-running {
            background: #cce5ff;
            color: #004085;
        }
        
        .status-completed {
            background: #d4edda;
            color: #155724;
        }
        
        .status-error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .model-history {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        .model-history h2 {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 15px;
        }
        
        .model-card {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            font-size: 0.9em;
            border-left: 4px solid #007bff;
        }
        
        .model-card h3 {
            margin: 0 0 8px 0;
            color: #007bff;
            font-size: 1em;
        }
        
        .model-card p {
            margin: 4px 0;
            color: #666;
        }
        
        .model-card .timestamp {
            font-size: 0.8em;
            color: #999;
            margin-top: 8px;
        }
        
        .model-card:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="config-section">
            <h1>Model Configuration</h1>
            <form id="training-form">
                <div class="form-group">
                    <label>Batch Size:</label>
                    <input type="number" name="batch_size" value="32" min="1" max="512">
                </div>
                <div class="form-group">
                    <label>Optimizer:</label>
                    <select name="optimizer">
                        <option value="adam">Adam</option>
                        <option value="sgd">SGD</option>
                        <option value="rmsprop">RMSprop</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Learning Rate:</label>
                    <input type="number" name="learning_rate" value="0.001" step="0.0001">
                </div>
                <div class="form-group">
                    <label>Epochs:</label>
                    <input type="number" name="epochs" value="10" min="1" max="100">
                </div>
                <div class="form-group">
                    <label>Number of Filters:</label>
                    <input type="number" name="num_filters" value="32" min="1">
                </div>
                <div class="form-group">
                    <label>Kernel Size:</label>
                    <input type="number" name="kernel_size" value="3" min="1" max="7">
                </div>
                <div class="form-group">
                    <label>Pooling Layer:</label>
                    <select name="pooling">
                        <option value="max">Max Pooling</option>
                        <option value="avg">Average Pooling</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Activation Function:</label>
                    <select name="activation">
                        <option value="relu">ReLU</option>
                        <option value="tanh">Tanh</option>
                        <option value="sigmoid">Sigmoid</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Model Name:</label>
                    <input type="text" name="model_name" required placeholder="Enter model name">
                </div>
                <div class="button-group">
                    <button type="submit" id="startButton">Start Training</button>
                    <button type="button" id="stopButton">Stop Training</button>
                </div>
            </form>
            <div class="model-history">
                <h2>Recent Models</h2>
                <div id="model-list">
                    <!-- Model history will be populated here -->
                </div>
            </div>
        </div>
        
        <div class="plots-section">
            <h1>Training Progress</h1>
            <div class="progress-container">
                <div class="status-badge" id="training-status">Idle</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-stats">
                    <span id="epoch-info">Epoch: 0/0</span>
                    <span id="time-elapsed">Time: 0:00</span>
                    <span id="accuracy-info">Accuracy: 0%</span>
                </div>
            </div>
            <div id="plots">
                <div id="loss-plot"></div>
                <div id="accuracy-plot"></div>
            </div>
        </div>
    </div>

    <script>
        let startTime;
        let trainingActive = false;
        
        function formatModelCard(config) {
            return `
                <div class="model-card">
                    <h3>${config.model_name}</h3>
                    <p>Filters: ${config.num_filters} | Kernel: ${config.kernel_size}x${config.kernel_size}</p>
                    <p>Activation: ${config.activation} | Pooling: ${config.pooling}</p>
                    <p>Optimizer: ${config.optimizer} (lr: ${config.learning_rate})</p>
                    <p>Batch Size: ${config.batch_size} | Epochs: ${config.epochs}</p>
                    <div class="timestamp">${new Date(config.timestamp).toLocaleString()}</div>
                </div>
            `;
        }

        function updateModelHistory() {
            fetch('/get_model_history')
                .then(response => response.json())
                .then(models => {
                    const modelList = document.getElementById('model-list');
                    modelList.innerHTML = models.map(formatModelCard).join('');
                })
                .catch(error => console.error('Error fetching model history:', error));
        }
        
        document.getElementById('training-form').onsubmit = async function(e) {
            e.preventDefault();
            if (trainingActive) return;
            
            const startButton = document.getElementById('startButton');
            const stopButton = document.getElementById('stopButton');
            
            try {
                const formData = new FormData(this);
                const config = Object.fromEntries(formData.entries());
                config.timestamp = new Date().toISOString();  // Add timestamp
                
                startButton.style.display = 'none';
                stopButton.style.display = 'block';
                trainingActive = true;
                startTime = new Date();
                
                updateStatus('running');
                
                const response = await fetch('/start_training', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    startMonitoring();
                    updateModelHistory();  // Update model history after successful start
                } else {
                    throw new Error(data.error || 'Failed to start training');
                }
            } catch (error) {
                console.error('Error:', error);
                updateStatus('error', error.message);
                resetButtons();
            }
        };
        
        document.getElementById('stopButton').onclick = async function() {
            try {
                const response = await fetch('/stop_training', { method: 'POST' });
                if (response.ok) {
                    updateStatus('completed', 'Training stopped by user');
                    resetButtons();
                }
            } catch (error) {
                console.error('Error stopping training:', error);
            }
        };
        
        function resetButtons() {
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('stopButton').style.display = 'none';
            trainingActive = false;
        }
        
        function updateStatus(status, message = '') {
            const statusBadge = document.getElementById('training-status');
            statusBadge.className = 'status-badge status-' + status;
            
            switch(status) {
                case 'running':
                    statusBadge.textContent = 'Training';
                    break;
                case 'completed':
                    statusBadge.textContent = 'Completed';
                    resetButtons();
                    break;
                case 'error':
                    statusBadge.textContent = 'Error';
                    resetButtons();
                    break;
            }
        }
        
        function updateProgress(currentEpoch, totalEpochs, accuracy) {
            const progressFill = document.getElementById('progress-fill');
            const epochInfo = document.getElementById('epoch-info');
            const timeElapsed = document.getElementById('time-elapsed');
            const accuracyInfo = document.getElementById('accuracy-info');
            
            // Update progress bar
            const progress = (currentEpoch / totalEpochs) * 100;
            progressFill.style.width = `${progress}%`;
            
            // Update epoch info
            epochInfo.textContent = `Epoch: ${currentEpoch}/${totalEpochs}`;
            
            // Update time elapsed
            if (startTime) {
                const elapsed = Math.floor((new Date() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                timeElapsed.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Update accuracy
            accuracyInfo.textContent = `Accuracy: ${accuracy.toFixed(2)}%`;
        }
        
        function startMonitoring() {
            function updatePlots() {
                if (!trainingActive) return;
                
                fetch('/get_training_stats')
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) throw new Error(data.error);
                        
                        // Update progress
                        if (data.epochs.length > 0) {
                            const currentEpoch = data.epochs.length;
                            const totalEpochs = document.querySelector('input[name="epochs"]').value;
                            const latestAccuracy = data.train_acc[data.train_acc.length - 1] || 0;
                            updateProgress(currentEpoch, totalEpochs, latestAccuracy);
                        }
                        
                        // Update plots
                        const traceLoss1 = {
                            x: data.epochs,
                            y: data.train_loss,
                            name: 'Training Loss',
                            type: 'scatter'
                        };
                        const traceLoss2 = {
                            x: data.epochs,
                            y: data.val_loss,
                            name: 'Validation Loss',
                            type: 'scatter'
                        };
                        Plotly.newPlot('loss-plot', [traceLoss1, traceLoss2], {
                            title: 'Training and Validation Loss',
                            xaxis: { title: 'Epoch' },
                            yaxis: { title: 'Loss' }
                        });

                        const traceAcc1 = {
                            x: data.epochs,
                            y: data.train_acc,
                            name: 'Training Accuracy',
                            type: 'scatter'
                        };
                        const traceAcc2 = {
                            x: data.epochs,
                            y: data.val_acc,
                            name: 'Validation Accuracy',
                            type: 'scatter'
                        };
                        Plotly.newPlot('accuracy-plot', [traceAcc1, traceAcc2], {
                            title: 'Training and Validation Accuracy',
                            xaxis: { title: 'Epoch' },
                            yaxis: { title: 'Accuracy', range: [0, 100] }
                        });
                        
                        if (data.status === 'completed') {
                            updateStatus('completed');
                            trainingActive = false;
                        } else if (data.status === 'error') {
                            updateStatus('error', data.error);
                            trainingActive = false;
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        if (trainingActive) {
                            setTimeout(updatePlots, 2000);
                        }
                    });
            }
            
            updatePlots();
            const intervalId = setInterval(() => {
                if (trainingActive) {
                    updatePlots();
                } else {
                    clearInterval(intervalId);
                }
            }, 2000);
        }
    </script>
</body>
</html> 